var reverseBits = function (n) {
	/* 
    #===========================================================# 
    | 접근 방식 1                                               | 
    |-----------------------------------------------------------|
    | n을 우쉬프트 하면서 마지막 값이 1일때 뒤집은 2진수에는    |
    | 좌쉬프트 후 +1을 함                                       |
    |                                                           |
    | 1011 이 있을 때, 뒤집은 2진수 초기값 = 0                  |
    | ---------------------------------------------             |
    | 2로 나눈 나머지 = 1                                       |
    | 뒤집은 값 좌쉬프트 후 + 1 => 뒤집은 2진수 = 1             |
    | n 우쉬프트 => 101                                         |
    | ---------------------------------------------             |
    | 2로 나눈 나머지 = 1                                       |
    | 뒤집은 값 좌쉬프트 후 + 1 => 뒤집은 2진수 = 11            |
    | n 우쉬프트 => 10                                          |
    | ---------------------------------------------             |
    | 2로 나눈 나머지 = 0                                       |
    | 뒤집은 값 좌쉬프트 => 뒤집은 2진수 = 110                  |
    | n 우쉬프트 => 1                                           |
    | ---------------------------------------------             |
    | 2로 나눈 나머지 = 1                                       |
    | 뒤집은 값 좌쉬프트 후 + 1 => 뒤집은 2진수 = 1101          |
    | n 우쉬프트 => 0                                           |
    | ---------------------------------------------             |
    | 하지만 여기서 문제점은 javascript에서 비트 연산자는       |
    | 32비트 연산만 가능해서 32번째 비트를 채우려면 문자를      |
    | 추가하는 식으로 변경                                      |
    #===========================================================#
    */
	let reversed = 0;
	let cnt = 0;
	while (n !== 0) {
		if (cnt === 31) {
			reversed = reversed.toString(2);
			if (n === 1) {
				reversed += '1';
			} else {
				reversed += '0';
			}
			cnt++;
			break;
		}
		cnt++;
		reversed <<= 1;
		if (n % 2 === 1) {
			reversed += 1;
		}
		n >>>= 1;
	}
	while (cnt < 32) {
		cnt++;
		reversed = reversed.toString(2) + '0';
	}

	return reversed
		.split('')
		.reduce((acc, val, idx, arr) => acc + val * Math.pow(2, arr.length - 1 - idx), 0);

	/* 
    #============================================================# 
    | 접근 방식 2                                                | 
    |------------------------------------------------------------|
    | 위 방식은 32번째 비트를 채울때 문자열로 변경하여 계산하므로|
    | 처음부터 문자열로 계산한 것보다 비효율적일 것              |
    | 따라서 처음부터 문자열로 변경하여 계산                     |
    #============================================================#
    */
	let reversed = n.toString(2).split('').reverse();
	while (reversed.length < 32) {
		reversed.push('0');
	}
	return reversed.reduce((acc, val, idx, arr) => acc + val * Math.pow(2, arr.length - 1 - idx), 0);
};
