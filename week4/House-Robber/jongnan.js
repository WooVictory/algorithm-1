var rob = function (nums) {
	/* 
    #=====================================================================================# 
    | 접근 방식 1                                                                         | 
    |-------------------------------------------------------------------------------------|
    | 메모이제이션을 하기 위해 dp라는 배열을 만듦                                         |
    | dp 배열은 2중 배열로 각 row는 집 번호를 의미                                        |
    | row 안에 각 값은 0 : 털지 않았을 경우, 1: 털었을 경우                               |
    | 즉, dp[2][0]은 2번째 집을 털지 않았을 경우이며, dp[2][1]은 2번째 집을 털었을 경우   |
    |                                                                                     |
    | 현재 집을 털었을 경우, 이전 집은 무조건 털지 않아야함                               |
    | 현재 집을 털지 않았을 경우, 이전 집은 털었거나 털지 않았을 두가지 경우가            |
    | 모두 성립이 가능하므로 둘 중 큰 경우의 수를 선택                                    |
    #=====================================================================================#
    */
	if (nums.length === 0) return 0;
	const dp = new Array(nums.length).fill(0).map((_) => new Array(2).fill(0));

	dp[0][0] = 0;
	dp[0][1] = nums[0];
	for (let i = 1; i < nums.length; i++) {
		dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
		dp[i][1] = dp[i - 1][0] + nums[i];
	}
	return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
};
